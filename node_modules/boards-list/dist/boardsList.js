"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.__tests = exports.createBoardsList = exports.isInferredBoardsListItem = exports.getInferredBoardOrBoard = exports.isBoardsListItem = exports.isMultiBoardsBoardsListItem = void 0;
const natural_compare_1 = __importDefault(require("natural-compare"));
const api_1 = require("./api");
const nls = {
    unconfirmedBoard: 'Unconfirmed board',
    selectBoard: 'Select Board',
    notConnected: '[not connected]',
    unknown: 'Unknown',
};
function findUniqueBoardName(item) {
    const distinctNames = new Set(item.boards.map(({ name }) => name));
    if (distinctNames.size === 1) {
        const name = Array.from(distinctNames.keys()).shift();
        if (name) {
            return name;
        }
    }
    return undefined;
}
function isMultiBoardsBoardsListItem(arg) {
    return (isBoardsListItem(arg) &&
        arg.boards !== undefined &&
        Array.isArray(arg.boards) &&
        Boolean(arg.boards.length) &&
        arg.boards.every(api_1.isBoardIdentifier));
}
exports.isMultiBoardsBoardsListItem = isMultiBoardsBoardsListItem;
function isBoardsListItem(arg) {
    return (Boolean(arg) &&
        typeof arg === 'object' &&
        arg.port !== undefined &&
        (0, api_1.isPort)(arg.port) &&
        (arg.board === undefined ||
            (arg.board !== undefined &&
                (0, api_1.isBoardIdentifier)(arg.board))));
}
exports.isBoardsListItem = isBoardsListItem;
function getBoardOrInferredBoard(item) {
    let board = undefined;
    board = item.board;
    if (!board && isInferredBoardsListItem(item)) {
        board = item.inferredBoard;
    }
    return board;
}
function getInferredBoardOrBoard(item) {
    if (isInferredBoardsListItem(item)) {
        return item.inferredBoard;
    }
    return item.board;
}
exports.getInferredBoardOrBoard = getInferredBoardOrBoard;
function isInferredBoardsListItem(arg) {
    return (isBoardsListItem(arg) &&
        arg.type !== undefined &&
        isInferenceType(arg.type) &&
        arg.inferredBoard !== undefined &&
        (0, api_1.isBoardIdentifier)(arg.inferredBoard));
}
exports.isInferredBoardsListItem = isInferredBoardsListItem;
const inferenceTypeLiterals = [
    /**
     * The user has manually selected the board (FQBN) for the detected port of a 3rd party board (no matching boards were detected by the CLI for the port)
     */
    'manually-selected',
    /**
     * The user has manually edited the detected FQBN of a recognized board from a detected port (there are matching boards for a detected port, but the user decided to use another FQBN)
     */
    'board-overridden',
];
function isInferenceType(arg) {
    return (typeof arg === 'string' &&
        inferenceTypeLiterals.includes(arg));
}
/**
 * Compare precedence:
 *  1. `BoardsListItem#port#protocol`: `'serial'`, `'network'`, then natural compare of the `protocol` string.
 *  1. `BoardsListItem`s with a `board` comes before items without a `board`.
 *  1. `BoardsListItem#board`:
 *     1. Items with `'arduino'` vendor ID in the `fqbn` come before other vendors.
 *     1. Natural compare of the `name`.
 *  1. If the `BoardsListItem`s do not have a `board` property:
 *     1. Ambiguous boards come before no boards.
 *     1. `BoardsListItem#port#address` natural compare is the fallback.
 */
function BoardsListItemComparator(left, right) {
    // sort by port protocol
    let result = (0, api_1.portProtocolComparator)(left.port, right.port);
    if (result) {
        return result;
    }
    // compare by board
    result = (0, api_1.boardIdentifierComparator)(getBoardOrInferredBoard(left), getBoardOrInferredBoard(right));
    if (result) {
        return result;
    }
    // detected ports with multiple discovered boards come before any other unknown items
    if (isMultiBoardsBoardsListItem(left) &&
        !isMultiBoardsBoardsListItem(right)) {
        return -1;
    }
    if (!isMultiBoardsBoardsListItem(left) &&
        isMultiBoardsBoardsListItem(right)) {
        return 1;
    }
    // ambiguous boards with a unique board name comes first than other ambiguous ones
    if (isMultiBoardsBoardsListItem(left) && isMultiBoardsBoardsListItem(right)) {
        const leftUniqueName = findUniqueBoardName(left);
        const rightUniqueName = findUniqueBoardName(right);
        if (leftUniqueName && !rightUniqueName) {
            return -1;
        }
        if (!leftUniqueName && rightUniqueName) {
            return 1;
        }
        if (leftUniqueName && rightUniqueName) {
            return (0, natural_compare_1.default)(leftUniqueName, rightUniqueName);
        }
    }
    // fallback compare based on the address
    return (0, natural_compare_1.default)(left.port.address, right.port.address);
}
function createBoardsListLabels(boardsConfig, allPorts, selectedItem) {
    const { selectedBoard, selectedPort } = boardsConfig;
    const boardLabel = selectedBoard?.name || nls.selectBoard;
    let tooltip = '';
    if (!selectedBoard && !selectedPort) {
        tooltip = nls.selectBoard;
    }
    else {
        if (selectedBoard) {
            tooltip += (0, api_1.boardIdentifierLabel)(selectedBoard);
        }
        if (selectedPort) {
            if (tooltip) {
                tooltip += '\n';
            }
            tooltip += selectedPort.address;
            const index = (0, api_1.findMatchingPortIndex)(selectedPort, allPorts);
            if (index < 0) {
                tooltip += ` ${nls.notConnected}`;
            }
        }
    }
    return {
        boardLabel,
        portProtocol: selectedBoard ? selectedPort?.protocol : undefined,
        tooltip,
        selected: Boolean(selectedItem),
    };
}
function createBoardsListItemLabels(item) {
    const { port } = item;
    const portLabel = port.address;
    const portProtocol = port.protocol;
    let board = item.board; // use default board label if any
    if (isInferredBoardsListItem(item)) {
        board = item.inferredBoard; // inferred board overrides any discovered boards
    }
    // if the board is still missing, maybe it's ambiguous
    if (!board && isMultiBoardsBoardsListItem(item)) {
        const name = 
        // get a unique board name
        findUniqueBoardName(item) ??
            // or fall back to something else than unknown board
            nls.unconfirmedBoard;
        board = { name, fqbn: undefined };
    }
    const boardLabel = board?.name ?? nls.unknown;
    let boardLabelWithFqbn = boardLabel;
    if (board?.fqbn) {
        boardLabelWithFqbn += ` (${board.fqbn})`;
    }
    return {
        boardLabel,
        boardLabelWithFqbn,
        portLabel,
        portProtocol,
        tooltip: `${boardLabelWithFqbn}\n${portLabel}`,
    };
}
function createBoardsList(detectedPorts, boardsConfig = (0, api_1.emptyBoardsConfig)(), history = {}) {
    const items = [];
    for (const detectedPort of Object.values(detectedPorts)) {
        const item = createBoardsListItemUI(detectedPort, history);
        items.push(item);
    }
    items.sort(BoardsListItemComparator);
    const selectedIndex = findSelectedIndex(boardsConfig, items);
    const boards = collectBoards(items);
    const allPorts = collectPorts(items, detectedPorts);
    const labels = createBoardsListLabels(boardsConfig, allPorts, items[selectedIndex]);
    return {
        labels,
        items,
        boardsConfig,
        boards,
        selectedIndex,
        ports(predicate) {
            return filterPorts(allPorts, boardsConfig.selectedPort, predicate);
        },
        portsGroupedByProtocol() {
            const _allPorts = filterPorts(allPorts, boardsConfig.selectedPort);
            return portsGroupedByProtocol(_allPorts);
        },
        toString() {
            return JSON.stringify({
                labels,
                detectedPorts,
                boardsConfig,
                items,
                selectedIndex,
                history,
            }, null, 2);
        },
    };
}
exports.createBoardsList = createBoardsList;
function portsGroupedByProtocol(allPorts) {
    const result = {};
    for (const detectedPort of allPorts) {
        const protocol = detectedPort.port.protocol;
        if (!result[protocol]) {
            result[protocol] = Object.assign([], {
                matchingIndex: -1,
            });
        }
        const portsOnProtocol = result[protocol];
        portsOnProtocol.push(detectedPort);
    }
    const matchItem = allPorts[allPorts.matchingIndex];
    // the cached match index is per all ports. Here, IDE2 needs to adjust the match index per grouped protocol
    if (matchItem) {
        const matchProtocol = matchItem.port.protocol;
        const matchPorts = result[matchProtocol];
        matchPorts.matchingIndex = matchPorts.indexOf(matchItem);
    }
    return result;
}
function filterPorts(allPorts, selectedPort, predicate = () => true) {
    const ports = allPorts.filter(predicate);
    const matchingIndex = (0, api_1.findMatchingPortIndex)(selectedPort, ports);
    return Object.assign(ports, { matchingIndex });
}
function collectPorts(items, detectedPorts) {
    const allPorts = [];
    // to keep the order or the detected ports
    const visitedPortKeys = new Set();
    for (let i = 0; i < items.length; i++) {
        const { port } = items[i];
        const portKey = (0, api_1.createPortKey)(port);
        if (!visitedPortKeys.has(portKey)) {
            visitedPortKeys.add(portKey);
            const detectedPort = detectedPorts[portKey];
            if (detectedPort) {
                allPorts.push(detectedPort);
            }
        }
    }
    return allPorts;
}
function collectBoards(items) {
    const result = [];
    for (let i = 0; i < items.length; i++) {
        const boards = [];
        const item = items[i];
        const { port } = item;
        const board = getInferredBoardOrBoard(item);
        if (board) {
            boards.push({ board, port });
        }
        if (isMultiBoardsBoardsListItem(item)) {
            for (const otherBoard of item.boards) {
                if (!(0, api_1.boardIdentifierEquals)(board, otherBoard)) {
                    boards.push({ board: otherBoard, port });
                }
            }
        }
        boards.sort(BoardsListItemComparator);
        result.push(...boards);
    }
    return result;
}
function findSelectedIndex(boardsConfig, items) {
    if (!(0, api_1.isDefinedBoardsConfig)(boardsConfig)) {
        return -1;
    }
    const length = items.length;
    const { selectedPort, selectedBoard } = boardsConfig;
    const portKey = (0, api_1.createPortKey)(selectedPort);
    // find the exact match of the board and port combination
    for (let index = 0; index < length; index++) {
        const item = items[index];
        const { board, port } = item;
        if (!board) {
            continue;
        }
        if ((0, api_1.createPortKey)(port) === portKey &&
            (0, api_1.boardIdentifierEquals)(board, selectedBoard)) {
            return index;
        }
    }
    // find match from inferred board
    for (let index = 0; index < length; index++) {
        const item = items[index];
        if (!isInferredBoardsListItem(item)) {
            continue;
        }
        const { inferredBoard, port } = item;
        if ((0, api_1.createPortKey)(port) === portKey &&
            (0, api_1.boardIdentifierEquals)(inferredBoard, boardsConfig.selectedBoard)) {
            return index;
        }
    }
    return -1;
}
function createBoardsListItemUI(detectedPort, BoardsListHistory) {
    const item = createBoardsListItem(detectedPort, BoardsListHistory);
    const labels = createBoardsListItemLabels(item);
    const defaultAction = createDefaultAction(item);
    const otherActions = createOtherActions(item);
    return Object.assign(item, { labels, defaultAction, otherActions });
}
function createBoardsListItem(detectedPort, BoardsListHistory) {
    const { port, boards } = detectedPort;
    // boards with arduino vendor should come first
    boards?.sort(api_1.boardIdentifierComparator);
    const portKey = (0, api_1.createPortKey)(port);
    const inferredBoard = BoardsListHistory[portKey];
    if (!boards?.length) {
        let unknownItem = { port };
        // Infer unrecognized boards from the history
        if (inferredBoard) {
            unknownItem = {
                ...unknownItem,
                inferredBoard,
                type: 'manually-selected',
            };
        }
        return unknownItem;
    }
    else if (boards.length === 1) {
        const board = boards[0];
        let detectedItem = {
            port,
            board,
        };
        if (inferredBoard &&
            // ignore the inferred item if it's the same as the discovered board
            !(0, api_1.boardIdentifierEquals)(board, inferredBoard)) {
            detectedItem = {
                ...detectedItem,
                inferredBoard,
                type: 'board-overridden',
            };
        }
        return detectedItem;
    }
    else {
        let ambiguousItem = {
            port,
            boards,
        };
        if (inferredBoard) {
            ambiguousItem = {
                ...ambiguousItem,
                inferredBoard,
                type: 'manually-selected',
            };
        }
        return ambiguousItem;
    }
}
function createDefaultAction(item) {
    if (isInferredBoardsListItem(item)) {
        return createSelectAction({
            selectedBoard: item.inferredBoard,
            selectedPort: item.port,
        });
    }
    if (item.board) {
        return createSelectAction({
            selectedBoard: item.board,
            selectedPort: item.port,
        });
    }
    return createEditAction(item);
}
function createOtherActions(item) {
    if (isInferredBoardsListItem(item)) {
        const edit = createEditAction(item);
        if (item.type === 'board-overridden') {
            const revert = createSelectAction({
                selectedBoard: item.board,
                selectedPort: item.port,
            });
            return { edit, revert };
        }
        return { edit };
    }
    return {};
}
function createSelectAction(params) {
    return {
        type: 'select-boards-config',
        params,
    };
}
function createEditAction(item) {
    const params = {
        portToSelect: item.port,
    };
    if (isMultiBoardsBoardsListItem(item)) {
        const uniqueBoardName = findUniqueBoardName(item);
        params.query = uniqueBoardName ?? '';
        params.searchSet = item.boards;
    }
    else if (isInferredBoardsListItem(item)) {
        params.query = item.inferredBoard.name;
    }
    else if (item.board) {
        params.query = item.board.name;
    }
    else {
        params.query = '';
    }
    return {
        type: 'edit-boards-config',
        params,
    };
}
/**
 * (non-API)
 */
exports.__tests = {
    nls,
};
//# sourceMappingURL=boardsList.js.map